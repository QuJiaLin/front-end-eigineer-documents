## 一、本地开发工具
动态构建和Mock服务是本地开发服务器的主要功能。  
动态构建主要解决开发层面的问题，通过监听->修改->触发->构建的流程避免每次修改源码都需要重新构建，方便开发过程中即时调试。  
Mock服务主要解决与后端之间的协作问题，以提前约定好的规范为前提，通过本地服务器提供Mock数据辅助编写前端逻辑。

### 1.动态构建
前端开发过程中需要频繁的调试，尤其是调试CSS样式的时候，如果每次修改后都需要手动执行构建，再刷新页面，效率就会十分低。动态构建的目的是通过自动构建代替人工操作，减少工作量。
<img src="../img/runtime-compile.png" width="400" />

在动态编译完成之后，应立即触发浏览器自动更新，从而让浏览器获取重新编译之后的资源，这种方案被称为**Livereload**。
Livereload的原理是在浏览器和服务器之间建立WebSocket连接，服务器端在执行动态编译之后发送reload事件到浏览器，浏览器接收事件后重新刷新整个页面。
Livereload有一个缺点是无法保存页面状态，浏览器接收到reload事件后，页面刷新，之前在浏览器端的修改以及各种数据状态全部重置，有的状态需要重复三四次操作流程才能重现。
HMR（Hot Module Replacement）很好的解决了这个问题，HMR以局部更新取代整体页面刷新，HMR只是将更新的模块进行替换，浏览器不会刷新页面。

webpack-dev-server是webpack官方提供的用于搭建本地开发环境的服务器框架，提供动态编译、HMR(热更新)等功能。

### 2.Mock服务
在前后端开发人员进入正式开发之前，前端可以使用Mock服务去模拟数据，不依赖后端接口数据投入开发。  
Mock的前提是在正式进入开发前，前后端开发需要协商好数据接口的规范细节，包括请求方法、入参、返回值等。服务端开发按照规范实现接口，前端开发依据规范Mock数据编写前端逻辑。

#### 2.1 假数据
在业务代码中声明变量，代替接口返回的数据，这样调试十分方便，不需要借助任何的工具，但是也存在很多问题。
* 开发完成后需要将无用代码删除，将数据源切换成后端接口，可能会忘记修改某个接口就上线了。
* 无法模拟接口的请求流程和异常处理的过程。

#### 2.2 客户端Mock
以Mock.js为代表的Mock，工作原理是在客户端拦截JavaScript代码发出的异步请求并返回由Mock.js创建的假数据。可以将客户端的Mock代码单独写成一个Js文件，上线后删除，但是依然存在需要将Mock代码删除的问题，所以就存在一定的产品质量隐患。

#### 2.3 服务端Mock
无论是假数据还是客户端Mock的方式，都需要去修改业务代码，但是Mock数据的过程应该对前端开发是透明的，所以我们应该提供Mock服务。
在开发阶段使用Mock Server提供的与真实接口规范和逻辑一致的接口进行开发。开发完成后，将Mock接口的地址改成真实服务端的接口地址。

比如现有的一些Mock平台，前后端确定接口规范后，可以记录到这些平台上，明确返回数据的格式以及数据类型，平台会提供Mock数据的接口，这样子减少了后期开发过程中前后端的沟通成本，也减少了Mock数据与业务代码的耦合。

还有另一种更好的方案，就是通过代理的方式去处理请求。业务代码中请求的链接就是真实服务端的接口地址，但是在开发阶段，我们通过浏览器插件实现代理，所有请求都会被拦截下来，直接返回Mock平台的数据，这样对于前端来说，整个Mock过程无感知，最后连接口地址都不用改。