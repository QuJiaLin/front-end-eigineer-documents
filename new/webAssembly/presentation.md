### 开场

之前前端周会上听大家对wasm很感兴趣，我也是对这块很感兴趣，下去后找了些文档和文章来看了，了解了wasm的主要作用以及基本原理，还有一些核心概念，就想今天给大家简单分享一下。

### 目录
我今天要分享的内容主要分为四部分，分别是：
* wasm是什么？
* 为什么要用wasm？
* wasm的原理以及如何使用？
* wasm未来的发展

### What
首先我们来看第一部分，wasm是什么？

wasm不是一种编程语言，而是一种字节码标准（字节码是一种中间码），wasm主要是提供一些新特性并关注于性能提升，其目标是充分发挥硬件能力以达到native的执行效率。
wasm不是我们去手工编写的，而是通过C、C++、Rust等语言编译后生成的字节码，编译后需要放到wasm虚拟机才能运行。
wasm主要应用于一些需要大量计算或者关注于性能的场景，例如...等场景。如果没有wasm的话，我们只能用js来做，虽然js现在已经足够强大了，但是会存在性能瓶颈。
而wasm可以把一些复杂计算从后端转移到前端来做，可以用接近native的性能做这些事情。

Js从95年诞生时，只是作为一些表单校验的脚本，运行性能一直很差，直到08年左右出现了JIT编译器，出现了V8引擎，js的运行速度得到大幅提升，还诞生了node.js可以进行服务端开发，js能做的事情也越来越多。但是js开发仍让受到限制，而15年出现的wasm是对js运行性能的又一次提升。

了解了wasm是什么，我们来看一个wasm的示例，左边是一段c++代码，右边就是这段编译生成的wasm字节码。wasm字节码和Java的机器码很像，它能够以接近native的速度装载运行，无需解释执行。

接下来我们看下wasm的目标，主要是四个方向：
* 快速、高效、可移植。这个意思是wasm希望通过硬件的能力，在不同的平台上，能以接近native的速度运行。
* 可读、可调试。wasm是一种低级语言，但是它也有一种我们可以阅读的中间版本，方便我们进行调试，像C语言会编译成汇编语言作为IR。
* 保持安全。wasm是在浏览器的wasm沙箱中运行的，和其他web代码一样，遵循浏览器的安全策略。
* 不破坏原有web技术体系。wasm的设计原则是和其他web技术共存，是对原有技术做一个补充。它是为了完善js而不是取代js。

### Why
了解了wasm是什么，能用来做什么，以及它的目标之后，我们来看第二部分：为什么要用wasm？也就是wasm究竟能给我们什么好处。

要了解这个问题，我们首先来看下js存在的问题。
有一个经典的前端面试问题：从输入URl到页面加载的过程中，发生了什么？
这个问题的答案简单来说就是：DNS解析、建立网络链接、请求资源、浏览器js引擎解析、渲染引擎渲染，中间具体细节不深挖，我们重点关注下js引擎解析js代码的过程。
JS是弱类型的解释型语言，变量类型可变且是运行时编译的，所以js引擎不仅需要解析代码，编译代码，还需要对运行性能进行优化和再优化。

有时候也会因为运行环境的不同而导致运行速度变差，同时js还需要做内存回收，也会影响性能。

而且JS语法太灵活就导致一些大型项目维护困难，js的性能不满足一些场景的需要。这些都是js的痛点。

针对这些问题，我们现在也有一些解决方案。
例如在编译打包的过程中，我们可以做tree shaking，以及对编译结果进行压缩等。
针对js弱类型难以管理的问题，我们有typescript。
但是这些仍然解决不了js运行速度的问题。
针对js运行时编译的性能问题，google开发了dart，可以打包成二进制文件，在浏览器虚拟机中运行，目标是取代js，不过后来出现了node.js，dart的浏览器虚拟机也只有chromeium支持，dart就一直处于边缘地位。

其中还有asm.js，asm.js是js的严格子集，只能使用js语法的一部分。asm的变量类型都是静态类型，且取消了垃圾回收机制。
一旦 JavaScript 引擎发现运行的是asm.js，就知道这是经过优化的代码，可以跳过语法分析这一步，直接转成汇编语言。另外，浏览器还会调用WebGL通过GPU执行asm.js，即asm.js的执行引擎与普通的JavaScript脚本不同。这些都是asm.js运行较快的原因。asm.js在浏览器里的运行速度，大约是原生代码的50%左右。
但是仍需要js引擎把asm.js代码编译成字节码。

对于js的这些问题，wasm都能解决，wasm的优势如下：
* webAssembly体积更小，请求更快
* Js需要被解析为抽象语法树，解析后的代码变成了IR，提供给JS引擎编译成机器码。浏览器只解析真正需要用到的代码。而WebAssembly只需要解码，并检查是否有语法错误，因为它本身就是IR。
* WebAssembly的好处：
	* 编译器不用检查变量类型
	* 编译器不需要根据不同的变量类型编译相同的代码段
	* 许多优化工作，在用LLVM编译的时候已经解决了
* 如果JIT判断优化过的代码不合理，有时会扔掉优化的代码，然后重新尝试优化。会有两个步骤消耗性能：
	* 放弃优化代码，回退到基线编译器版本
	* 如果该段代码仍然被多次调用，JIT需要再次将这段代码进行优化
在WebAssembly中，变量类型都是确定的，所以编译器不需要判断变量类型是否正确。 
* 许多JIT在执行时为js做的优化，在执行WebAssembly的时候并不需要。
* 写js代码时，我们不用关心变量内存回收。所以性能也是不可控的。现在，WebAssembly不支持变量自动回收，需要手动操作。增加了操作成本，但是代码执行效率更高。


### Principle & How?

知道了wasm有怎样的能力，接下来我们来了解下为什么wasm有这样的能力，以及如何使用wasm。

首先我们来具体了解一些js引擎做了什么。
我们知道我们先在学习的编程语言都是高级语言，有我们能理解的基本语法，但是计算机是不理解我们的语法的，计算机只认识0101二进制的机器码，所以编程语言都需要一个编译成机器码的过程。

在编译时间这个维度，编程语言分成编译型语言和解释型语言，这个大家都理解。
编译型语言的优点就是可以在编译时就进行优化，将代码编译成机器码，然后无需再次编译就可以直接运行。它的缺点是编译耗时，但是编译结果运行速度快。
解释型语言就是边解释边执行，而且每次执行都需要重新编译。
运行一些相同的代码就会存在问题。例如循环中的代码，解释器需要不断重复的编译这段代码。
因为web代码需要快速运行启动，所以浏览器在开始就会使用解释器执行js代码。

这个编译过程类比语言翻译的过程，解释型就是同声传译，编译型就是记录下来再翻译。

那么js引擎在这个过程中做了什么呢？我们来看一下：
主要分为五个部分：解析、编译及优化、再优化、执行、垃圾回收。主要是这五块内容。
* Parsing：把源代码变成解释器可以运行的代码。
* Compiling + optimizing：基线编译器和优化编译器所花的时间，一些优化编译器的工作不在主线程进行，所以不包含在其中。
* Re-optimizing：JIT发现优化假设错误，丢弃优化代码所花的时间。包括去优化的时间、抛弃并返回到基线编译器的时间。
* Execution：执行代码。
* Garbage collection：清理内存

现在js引擎中都有JIT编译器，不同浏览器的JIT实现方式有些不同，但是基本原理是一样的：
JIT编译器由3部分组成，分别是：monitor、baseline compiler、optimizing compiler。

monitor的作用是在代码运行时记录每段代码运行的次数和适用的类型。
一开始，monitor只是运行解释器中的内容。如果一段代码运行了几次，那这段代码就被标记为warm，如果运行了很多次，就被标记为hot。
例如我们看右边的这段代码，代码里是一段循环函数，函数执行时，循环里的这段代码会被执行多次，就会被monitor记录，先被标记为warm，然后被标记为hot。然后baseline compiler和optimizing compiler会做一些优化的工作。

如果一个函数执行了几次，monitor就会把这段代码发给编译器进行编译，然后保存编译结果。
函数的每一行都会被编译成一个“存根”，行数和变量类型作为存根的索引。如果monitor发现再次使用相同的变量在执行代码，就会直接返回编译后的结果。baseline compiler并不会花时间进行优化，如果一段代码执行次数很多，还是值得花时间进行优化的。

当一段代码被执行多次，monitor会把这段代码发给优化编译器，这段代码会编译成一个性能更好的版本被存储起来。
它会假定特定构造函数创建的所有对象结构相同，即所有对象属性名相同，并且这些属性的添加顺序相同，然后它会基于这个假设去做一些优化。
优化编译器会用monitor收集的代码执行结果进行一些处理。例如，如果之前的循环代码中，有一个值总是true，它会假设这个值在之后的循环中也是true。
**但是JavaScript的执行结果并不能得到保证。**
所以在代码执行前需要检查假定是否合理。如果合理，则运行编译后的代码，如果不合理，JIT会认定假定错误，并废弃这段编译后的代码。

**进程回退到解释器版本或基线编译器版本，被称为去优化。**

优化编译器会加快代码的运行性能，但是有时候会引起难以预测的性能问题，如果你的代码不断的被优化和去优化，它的性能可能还不如基线编译器的版本。
许多浏览器添加了对优化-去优化循环的限制，如果JIT尝试了10次优化，仍未成功，则会停止优化。

我们通过一个具体的例子来看一下，JIT做了什么。

从这个例子中我们可以看出，虽然js有了这些改进，但是JS的性能仍是不可预测的。为了让代码运行的更快，JIT增加了以下工作：
* 优化和去优化的过程需要花时间
* monitor需要的内存和应急回退时恢复信息的内存
* 存储基线和优化版本函数的内存

在了解这些之后，我们就知道wasm究竟在哪些方面比js执行的更快。
* 首先是网络请求，wasm直接请求的是字节码，体积必然比js更小
* wasm优化的过程已经在编译阶段做好了，节约了这部分时间。

WebAssembly 模块以二进制的格式发送到浏览器，并在专有虚拟机上执行。这个虚拟机与 JavaScript 虚拟机共享资源，如内存和线程。WebAssembly 模块总是与 JavaScript 代码一起使用，在必要的时候可以执行一些有用的操作。

我们知道，编译器能够将源代码翻译为可执行机器码，如果简单了解编译原理的话，就能知道传统编译器分为三部分：
* 前端：将源代码翻译为中间表示（IR, intermediate representation）
	* 预处理器：include<stdio.h>内容替换
	* 词法分析器
	* 语法分析器
	* 语义分析器
	* 中间表示生成器
* 优化器：对IR进行分析，将其翻译成更高效的方式
* 后端：将IR映射为目标硬件的机器码
	* 指令选取：
	* 寄存器分配：
	* 指令调度：

了解了wasm在哪些方面对js性能做了提升后，我们来看下wasm的核心概念以及wasm如何使用。

wasm的核心概念有下面几个部分：
* 模块：表示一个已经被浏览器编译为可执行机器码的WebAssembly二进制代码。
* 内存：ArrayBuffer，大小可变。本质上是连续的字节数组，WebAssembly的低级内存存取指令可以对它进行读写操作。
* 表格：带类型数组，大小可变。
* 实例：一个模块及其在运行时使用的所有状态，包括内存、表格和一系列导入值。

目前的主流浏览器也都基本支持了wasm。

### Future
在了解了wasm的原理以及如何使用之后，我们可能也发现了wasm也有很多不足，比如它不能直接操作DOM，这也是它的痛点。针对它的问题，w3c委员会给了一些优化的提案：

* 直接操作DOM：WebAssembly 没有任何方法可以与 DOM 直接交互
* 异常处理
* 一流的开发者工具：目前在浏览器中调试 WebAssembly 就像调试汇编一样，很少的开发者可以手动地把自己的源代码和汇编代码对应起来。
* 垃圾回收：WebAssembly 中的内存操作都是手动的。所以 WebAssembly 会考虑提供方便的 GC 功能，以方便开发者使用。
* ES6模块集成：`<script src=url type="module">`

### 结束
下面给大家看一个简单的Demo。

这些是参考链接。

谢谢大家。

