## webAssembly

在了解webAssembly之前，思考下面的这些问题，带着这些问题继续深入了解。

* webassembly是什么？
* webassembly解决了什么问题？
* 如何使用？
* 应用及前景
* 有哪些优缺点？
* 实现原理？

### 一、what is WebAssembly？

WebAssembly是一种用JavaScript以外其他编程语言编写代码，并在浏览器中运行该代码的方法。
WebAssembly实际上是一种字节码标准，可以快速装载运行，所以运行速度相对于JS解释执行大大提升。

### 二、performance history
JavaScript创建于1995年，起初运行性能并不快。

后来，人们开始关注性能。2008年，浏览器引入JIT(just-in-time)，JS执行性能快了10倍。随着性能的提升，JS开始应用于一些其他事情，例如用Node进行服务端编程。

随着WebAssembly的发展，我们可能正处于另一个拐点。
![performance history](./../imgs/performance-history.png) 

### 三、How JavaScript is run in the browser
JS引擎将js编译成机器码。电影：《降临》

将程序语言编译成机器码的两种方式：
* 解释器
* 编译器

#### 3.1 interpreter
解释器能够快速启动运行。在运行代码前不用编译整个程序。

因为web代码需要快速运行启动，所以浏览器在开始就会适用解释器执行js代码。

但如果运行一些相同的代码就会存在问题。例如循环中的代码，解释器需要不断重复的编译这段代码。

#### 3.2 compiler
启动程序之前需要花点时间来进行编译。但是执行循环代码的时候就会很快，因为它不用在每次循环时重复编译循环的代码。

另外一个不同点是，编译器可以对代码进行优化，所以它的性能更好。而解释器是运行时编译，所以不会有时间去做优化。

### 四、just-in-time compiler
不同浏览器的JIT实现方式有些不同，但是基本原理是一样的：
在JS引擎中设置一个monitor，在代码运行时，monitor记录每段代码运行的次数和适用的类型。

一开始，monitor只是运行解释器中的内容。如果一段代码运行了几次，那这段代码就被标记为warm，如果运行了很多次，就被标记为hot。

#### 4.1 baseline compiler
如果一个函数执行了几次，JIT就会把这段代码发给编译器进行编译，然后保存编译结果。

函数的每一行都会被编译成一个“存根”，行数和变量类型作为存根的索引。如果monitor发现再次使用相同的变量在执行代码，就会直接返回编译后的结果。

baseline compiler并不会花时间进行优化，如果一段代码执行次数很多，还是值得花时间进行优化的。

#### 4.2 optimizing compiler
当一段代码被执行多次，monitor会把这段代码发给优化编译器，这段代码会编译成一个性能更好的版本被存储起来。

它会假定特定构造函数创建的所有对象结构相同，即所有对象属性名相同，并且这些属性的添加顺序相同，然后它会基于这个假设去做一些优化。

优化编译器会用monitor收集的代码执行结果进行一些处理。例如，如果之前的循环代码中，有一个值总是true，它会假设这个值在之后的循环中也是true。

但是JavaScript的执行结果并不能得到保证。

所以在代码执行前需要检查假定是否合理。如果合理，则运行编译后的代码，如果不合理，JIT会认定假定错误，并废弃这段编译后的代码。

进程回退到解释器版本或基线编译器版本，被称为**去优化**。

优化编译器会加快代码的运行性能，但是有时候会引起难以预测的性能问题，如果你的代码不断的被优化和去优化，它的性能可能还不如基线编译器的版本。

许多浏览器添加了对优化-去优化循环的限制，如果JIT尝试了10次优化，仍未成功，则会停止优化。


#### 4.3 优化案例
参考：https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/

### 五、为什么需要webAssembly？
虽然有了这些改进，但是JS的性能仍是不可预测的。为了让代码运行的更快，JIT增加了以下工作：
* 优化和去优化
* monitor需要的内存和应急回退时回复信息的内存
* 存储基线和优化版本函数的内存

除了这些，还有可优化的空间，就是让性能变得可预测，这就是WebAssembly做的事情。
